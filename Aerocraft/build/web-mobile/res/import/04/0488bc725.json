[{"__type__":"cc.Material","_effectAsset":{"__uuid__":"a7YStUNeNCOKGpSntUY1g5"},"_defines":[{},{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{},{"mainColor":{"__type__":"cc.Color"},"shadeColor1":{"__type__":"cc.Color","r":39,"g":39,"b":39},"shadeColor2":{"__type__":"cc.Color","r":15,"g":15,"b":15},"specular":{"__type__":"cc.Color","a":76}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"a7YStUNeNCOKGpSntUY1g5"},"_defines":[{},{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{},{"mainColor":{"__type__":"cc.Color","r":236,"g":109,"b":92},"shadeColor1":{"__type__":"cc.Color","r":206,"g":140,"b":140},"shadeColor2":{"__type__":"cc.Color","r":126,"g":39,"b":39}}]},{"__type__":"cc.Mesh","_native":".bin","_struct":{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":43,"isNormalized":false}]}],"minPosition":{"__type__":"cc.Vec3","x":-0.5,"y":-0.5,"z":-0.5},"maxPosition":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5},"morph":{"subMeshMorphs":[null]}},"_dataLength":1224,"_hash":2480046122},[{"__type__":"cc.SceneAsset","scene":{"__id__":1}},{"__type__":"cc.Scene","_children":[{"__id__":2},{"__id__":3},{"__id__":5},{"__id__":6},{"__id__":20},{"__id__":26},{"__id__":32},{"__id__":38},{"__id__":44},{"__id__":55},{"__id__":50},{"__id__":46}],"_globals":{"__type__":"cc.SceneGlobals","ambient":{"__type__":"cc.AmbientInfo"},"planarShadows":{"__type__":"cc.PlanarShadowInfo"},"_skybox":{"__type__":"cc.SkyboxInfo"}}},{"__type__":"cc.Node","_name":"Main Light","_parent":{"__id__":1},"_components":[{"__type__":"cc.DirectionalLightComponent","node":{"__id__":2}}],"_lpos":{"__type__":"cc.Vec3","x":-6.745,"y":7.789,"z":11.683},"_lrot":{"__type__":"cc.Quat","x":-0.25,"y":-0.25,"z":-0.067,"w":0.933},"_id":"c0y6F5f+pAvI805TdmxIjx"},{"__type__":"cc.Node","_name":"Camera","_parent":{"__id__":1},"_components":[{"__id__":4}],"_lpos":{"__type__":"cc.Vec3","z":16.051},"_id":"c9DMICJLFO5IeO07EPon7U"},{"__type__":"cc.CameraComponent","_name":"Camera<CameraComponent>","node":{"__id__":3},"_color":{"__type__":"cc.Color","r":236,"g":218,"b":180},"_visibility":1822425087},{"__type__":"cc.Node","_name":"Camera","_parent":{"__id__":1},"_active":false,"_components":[{"__type__":"cc.CameraComponent","_name":"Camera<CameraComponent>","node":{"__id__":5},"_visibility":1822425087}],"_lpos":{"__type__":"cc.Vec3","x":2.709,"y":1.957,"z":5.577},"_lrot":{"__type__":"cc.Quat","x":-0.1347401092985915,"y":0.24794332306649827,"z":0.03484616158265037,"w":0.9587256940939372},"_euler":{"__type__":"cc.Vec3","x":-16,"y":29},"_id":"8ao8iGZJxC+Ig5irE7Svn8"},{"__type__":"cc.Node","_name":"aerocraft","_parent":{"__id__":1},"_children":[{"__id__":7},{"__id__":8},{"__id__":10},{"__id__":12},{"__id__":13},{"__id__":14},{"__id__":15},{"__id__":16},{"__id__":17}],"_components":[{"__type__":"33e66xLqT5G1IGn36LxsoEp","_name":"aerocraft<AerocraftSc>","node":{"__id__":6}},{"__type__":"cc.BoxColliderComponent","_name":"aerocraft<BoxColliderComponent>","node":{"__id__":6},"_center":{"__type__":"cc.Vec3","x":-0.2},"_size":{"__type__":"cc.Vec3","x":2.5,"y":1,"z":1}}],"_lpos":{"__type__":"cc.Vec3","x":-6.285},"_id":"93GxDJ33hKUKM5ULluKxbm"},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":7},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lrot":{"__type__":"cc.Quat","z":-0.026176948307873153,"w":0.9996573249755573},"_euler":{"__type__":"cc.Vec3","z":-3}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_children":[{"__id__":9}],"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":8},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-0.023,"y":-0.433,"z":0.356},"_lrot":{"__type__":"cc.Quat","z":-0.026176948307873153,"w":0.9996573249755573},"_lscale":{"__type__":"cc.Vec3","x":0.2,"y":0.5,"z":0.2},"_euler":{"__type__":"cc.Vec3","z":-3}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":8},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":9},"_materials":[{"__uuid__":"5aspYmu8VMPIZXFA4hKasL"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":0.0012234715833017162,"y":-0.16219667228018464},"_lscale":{"__type__":"cc.Vec3","x":1.4999999999999993,"y":0.9999999999999998,"z":0.75}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_children":[{"__id__":11}],"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":10},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-0.023,"y":-0.433,"z":-0.356},"_lrot":{"__type__":"cc.Quat","z":-0.026176948307873153,"w":0.9996573249755573},"_lscale":{"__type__":"cc.Vec3","x":0.2,"y":0.5,"z":0.2},"_euler":{"__type__":"cc.Vec3","z":-3}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":10},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":11},"_materials":[{"__uuid__":"5aspYmu8VMPIZXFA4hKasL"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":0.0012234715833017162,"y":-0.16219667228018464},"_lscale":{"__type__":"cc.Vec3","x":1.4999999999999993,"y":0.9999999999999998,"z":0.75}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":12},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-0.695,"y":0.084},"_lrot":{"__type__":"cc.Quat","z":-0.043619387365336,"w":0.9990482215818578},"_lscale":{"__type__":"cc.Vec3","x":0.9,"y":0.9,"z":0.9},"_euler":{"__type__":"cc.Vec3","z":-5}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":13},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-0.786,"y":0.46},"_lrot":{"__type__":"cc.Quat","z":-0.043619387365336,"w":0.9990482215818578},"_lscale":{"__type__":"cc.Vec3","x":0.7,"y":0.1,"z":4},"_euler":{"__type__":"cc.Vec3","z":-5}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":14},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-1.549,"y":0.242},"_lrot":{"__type__":"cc.Quat","z":-0.043619387365336,"w":0.9990482215818578},"_lscale":{"__type__":"cc.Vec3","x":0.9,"y":0.6,"z":0.6},"_euler":{"__type__":"cc.Vec3","z":-5}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":15},"_materials":[{"__uuid__":"c21Rk+P+NMPIGBKk1Ai7SD"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":-2.003,"y":0.757},"_lscale":{"__type__":"cc.Vec3","x":0.7,"y":0.5,"z":0.1}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":16},"_materials":[{"__uuid__":"8dyY2bAfZHJqzywvUtoyPs"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":0.572},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":1.1,"z":1.1}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":6},"_children":[{"__id__":18},{"__id__":19}],"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":17},"_materials":[{"__uuid__":"5aspYmu8VMPIZXFA4hKasL"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","node":{"__id__":17},"speed":{"__type__":"cc.Vec3","x":-1000}}],"_lpos":{"__type__":"cc.Vec3","x":0.803},"_lrot":{"__type__":"cc.Quat","x":0.17364817766693033,"w":0.984807753012208},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":0.2,"z":0.2},"_euler":{"__type__":"cc.Vec3","x":20}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":17},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":18},"_materials":[{"__uuid__":"5aspYmu8VMPIZXFA4hKasL"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":0.24750000000000005},"_lscale":{"__type__":"cc.Vec3","x":0.125,"y":7,"z":0.5}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":17},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":19},"_materials":[{"__uuid__":"5aspYmu8VMPIZXFA4hKasL"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}}],"_lpos":{"__type__":"cc.Vec3","x":0.24750000000000005},"_lrot":{"__type__":"cc.Quat","x":0.7071067811865475,"w":0.7071067811865476},"_lscale":{"__type__":"cc.Vec3","x":0.125,"y":7,"z":0.5},"_euler":{"__type__":"cc.Vec3","x":90}},{"__type__":"cc.Node","_name":"cloud","_parent":{"__id__":1},"_children":[{"__id__":21},{"__id__":22},{"__id__":23},{"__id__":24},{"__id__":25}],"_components":[{"__type__":"f5e5eGVJJxEwrvA6ZcYyTNb","_name":"cloud<ObjectMoveSc>","node":{"__id__":20},"speed":{"__type__":"cc.Vec3","x":-3}},{"__type__":"e40c7gXqOJEmabBu0ZSHyuW","node":{"__id__":20}}],"_lpos":{"__type__":"cc.Vec3","x":22.579,"y":-3.449,"z":-9.118},"_id":"4dAy5YadVIUrqKZLzCWCEr"},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":20},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":21},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","node":{"__id__":21},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lrot":{"__type__":"cc.Quat","x":0.372109858666352,"y":0.21567539362612112,"z":-0.08933567311009515,"w":0.8983526674850425},"_euler":{"__type__":"cc.Vec3","x":45,"y":27}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":20},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":22},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":22},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":1.357},"_lrot":{"__type__":"cc.Quat","x":0.3076227025512223,"y":0.54954459815089,"z":-0.22762882568297113,"w":0.7426669005930254},"_euler":{"__type__":"cc.Vec3","x":45,"y":73}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":20},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":23},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":23},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-2.026},"_lrot":{"__type__":"cc.Quat","x":0.24916643155374765,"y":0.04194481136611958,"z":-0.453832783366128,"w":0.8545130349669251},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":0.4,"z":0.4},"_euler":{"__type__":"cc.Vec3","x":45,"y":27,"z":-49}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":20},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":24},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":24},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-0.975},"_lrot":{"__type__":"cc.Quat","x":0.2381255344059835,"y":0.07737167630449064,"z":0.29917407394084033,"w":0.9207631221173763},"_lscale":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5},"_euler":{"__type__":"cc.Vec3","x":29,"z":36}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":20},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":25},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":25},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":0.855},"_lrot":{"__type__":"cc.Quat","x":0.12168585929584745,"y":0.6663248943108745,"z":-0.11150454630988288,"w":0.7271660216355412},"_lscale":{"__type__":"cc.Vec3","x":0.3,"y":0.3,"z":0.3},"_euler":{"__type__":"cc.Vec3","x":19,"y":85}},{"__type__":"cc.Node","_name":"cloud","_parent":{"__id__":1},"_children":[{"__id__":27},{"__id__":28},{"__id__":29},{"__id__":30},{"__id__":31}],"_components":[{"__type__":"f5e5eGVJJxEwrvA6ZcYyTNb","_name":"cloud<ObjectMoveSc>","node":{"__id__":26},"speed":{"__type__":"cc.Vec3","x":-3}},{"__type__":"e40c7gXqOJEmabBu0ZSHyuW","node":{"__id__":26}}],"_lpos":{"__type__":"cc.Vec3","x":11.77,"z":-9.118},"_id":"f5gV+ZMbFBSLgBWbKyT5Ww"},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":26},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":27},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","node":{"__id__":27},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lrot":{"__type__":"cc.Quat","x":0.372109858666352,"y":0.21567539362612112,"z":-0.08933567311009515,"w":0.8983526674850425},"_euler":{"__type__":"cc.Vec3","x":45,"y":27}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":26},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":28},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":28},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":1.511},"_lrot":{"__type__":"cc.Quat","x":0.3076227025512223,"y":0.54954459815089,"z":-0.22762882568297113,"w":0.7426669005930254},"_euler":{"__type__":"cc.Vec3","x":45,"y":73}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":26},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":29},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":29},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-2.026},"_lrot":{"__type__":"cc.Quat","x":0.24916643155374765,"y":0.04194481136611958,"z":-0.453832783366128,"w":0.8545130349669251},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":0.4,"z":0.4},"_euler":{"__type__":"cc.Vec3","x":45,"y":27,"z":-49}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":26},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":30},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":30},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-0.975},"_lrot":{"__type__":"cc.Quat","x":0.2381255344059835,"y":0.07737167630449064,"z":0.29917407394084033,"w":0.9207631221173763},"_lscale":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5},"_euler":{"__type__":"cc.Vec3","x":29,"z":36}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":26},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":31},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":31},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":0.855},"_lrot":{"__type__":"cc.Quat","x":0.12168585929584745,"y":0.6663248943108745,"z":-0.11150454630988288,"w":0.7271660216355412},"_lscale":{"__type__":"cc.Vec3","x":0.3,"y":0.3,"z":0.3},"_euler":{"__type__":"cc.Vec3","x":19,"y":85}},{"__type__":"cc.Node","_name":"cloud","_parent":{"__id__":1},"_children":[{"__id__":33},{"__id__":34},{"__id__":35},{"__id__":36},{"__id__":37}],"_components":[{"__type__":"f5e5eGVJJxEwrvA6ZcYyTNb","_name":"cloud<ObjectMoveSc>","node":{"__id__":32},"speed":{"__type__":"cc.Vec3","x":-3}},{"__type__":"e40c7gXqOJEmabBu0ZSHyuW","node":{"__id__":32}}],"_lpos":{"__type__":"cc.Vec3","x":1.565,"y":5.176,"z":-9.118},"_id":"58sBL8jHBFzrAZHq50SPVX"},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":32},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":33},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","node":{"__id__":33},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lrot":{"__type__":"cc.Quat","x":0.372109858666352,"y":0.21567539362612112,"z":-0.08933567311009515,"w":0.8983526674850425},"_euler":{"__type__":"cc.Vec3","x":45,"y":27}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":32},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":34},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":34},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":1.47},"_lrot":{"__type__":"cc.Quat","x":0.3076227025512223,"y":0.54954459815089,"z":-0.22762882568297113,"w":0.7426669005930254},"_euler":{"__type__":"cc.Vec3","x":45,"y":73}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":32},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":35},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":35},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-2.026},"_lrot":{"__type__":"cc.Quat","x":0.24916643155374765,"y":0.04194481136611958,"z":-0.453832783366128,"w":0.8545130349669251},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":0.4,"z":0.4},"_euler":{"__type__":"cc.Vec3","x":45,"y":27,"z":-49}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":32},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":36},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":36},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-0.975},"_lrot":{"__type__":"cc.Quat","x":0.2381255344059835,"y":0.07737167630449064,"z":0.29917407394084033,"w":0.9207631221173763},"_lscale":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5},"_euler":{"__type__":"cc.Vec3","x":29,"z":36}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":32},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":37},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":37},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":0.855},"_lrot":{"__type__":"cc.Quat","x":0.12168585929584745,"y":0.6663248943108745,"z":-0.11150454630988288,"w":0.7271660216355412},"_lscale":{"__type__":"cc.Vec3","x":0.3,"y":0.3,"z":0.3},"_euler":{"__type__":"cc.Vec3","x":19,"y":85}},{"__type__":"cc.Node","_name":"cloud","_parent":{"__id__":1},"_children":[{"__id__":39},{"__id__":40},{"__id__":41},{"__id__":42},{"__id__":43}],"_components":[{"__type__":"f5e5eGVJJxEwrvA6ZcYyTNb","_name":"cloud<ObjectMoveSc>","node":{"__id__":38},"speed":{"__type__":"cc.Vec3","x":-3}},{"__type__":"e40c7gXqOJEmabBu0ZSHyuW","node":{"__id__":38}}],"_lpos":{"__type__":"cc.Vec3","x":-11.331,"y":-2.599,"z":-9.118},"_id":"bfIemuJOdPOKitrHZP4VTX"},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":38},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":39},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","node":{"__id__":39},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lrot":{"__type__":"cc.Quat","x":0.372109858666352,"y":0.21567539362612112,"z":-0.08933567311009515,"w":0.8983526674850425},"_euler":{"__type__":"cc.Vec3","x":45,"y":27}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":38},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":40},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":40},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":1.848},"_lrot":{"__type__":"cc.Quat","x":0.3076227025512223,"y":0.54954459815089,"z":-0.22762882568297113,"w":0.7426669005930254},"_euler":{"__type__":"cc.Vec3","x":45,"y":73}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":38},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":41},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":41},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-2.026},"_lrot":{"__type__":"cc.Quat","x":0.24916643155374765,"y":0.04194481136611958,"z":-0.453832783366128,"w":0.8545130349669251},"_lscale":{"__type__":"cc.Vec3","x":0.4,"y":0.4,"z":0.4},"_euler":{"__type__":"cc.Vec3","x":45,"y":27,"z":-49}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":38},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":42},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":42},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":-0.975},"_lrot":{"__type__":"cc.Quat","x":0.2381255344059835,"y":0.07737167630449064,"z":0.29917407394084033,"w":0.9207631221173763},"_lscale":{"__type__":"cc.Vec3","x":0.5,"y":0.5,"z":0.5},"_euler":{"__type__":"cc.Vec3","x":29,"z":36}},{"__type__":"cc.Node","_name":"Cube","_parent":{"__id__":38},"_components":[{"__type__":"cc.ModelComponent","_name":"Cube<ModelComponent>","node":{"__id__":43},"_materials":[{"__uuid__":"80glZ6a4dJ24WmcKgVUPtk"}],"lightmapSettings":{"__type__":"cc.ModelLightmapSettings"},"_mesh":{"__uuid__":"12Y9dMgWdJKJGmTiZyQR9H@a804a"}},{"__type__":"47244XoN8NGxrfbiF8mt9KG","_name":"Cube<AutoRotateSc>","node":{"__id__":43},"speed":{"__type__":"cc.Vec3","x":30,"y":30}}],"_lpos":{"__type__":"cc.Vec3","x":0.855},"_lrot":{"__type__":"cc.Quat","x":0.12168585929584745,"y":0.6663248943108745,"z":-0.11150454630988288,"w":0.7271660216355412},"_lscale":{"__type__":"cc.Vec3","x":0.3,"y":0.3,"z":0.3},"_euler":{"__type__":"cc.Vec3","x":19,"y":85}},{"__type__":"cc.Node","_name":"game","_parent":{"__id__":1},"_components":[{"__type__":"42028uQe4dC1YNEoSNDrJU7","node":{"__id__":44},"particle1":{"__id__":45},"particle2":{"__id__":49},"labelPower":{"__id__":53},"labelScore":{"__id__":57},"objects":[{"__uuid__":"65PkiPiVxIu7Cttpf0LTy4"},{"__uuid__":"77wQVbPgdASr8Ggx1mnDA2"}]},{"__type__":"e4b26GtEZJH6qGM5yqlYmlK","node":{"__id__":44},"camera":{"__id__":4}}],"_id":"7aAzjaCGVEr7fHVGcjPSII"},{"__type__":"cc.ParticleSystemComponent","_name":"Particle<ParticleSystemComponent>","node":{"__id__":46},"_materials":[{"__uuid__":"eadHiwQI1AUrcD8NI1Xglf"},null],"startColor":{"__type__":"cc.GradientRange","color":{"__type__":"cc.Color","r":252,"g":29,"b":29}},"startSizeX":{"__id__":47},"startSize":{"__id__":47},"startSizeY":{"__type__":"cc.CurveRange"},"startSizeZ":{"__type__":"cc.CurveRange"},"startSpeed":{"__type__":"cc.CurveRange","constant":30},"startRotationX":{"__type__":"cc.CurveRange"},"startRotationY":{"__type__":"cc.CurveRange"},"startRotationZ":{"__id__":48},"startRotation":{"__id__":48},"startDelay":{"__type__":"cc.CurveRange"},"startLifetime":{"__type__":"cc.CurveRange","constant":0.1},"duration":0.3,"loop":false,"gravityModifier":{"__type__":"cc.CurveRange"},"rateOverTime":{"__type__":"cc.CurveRange","constant":80},"rateOverDistance":{"__type__":"cc.CurveRange"},"colorOverLifetimeModule":{"__type__":"cc.ColorOvertimeModule","color":{"__type__":"cc.GradientRange"}},"shapeModule":{"__type__":"cc.ShapeModule","_enable":true,"_shapeType":3,"shapeType":3,"arcSpeed":{"__type__":"cc.CurveRange","constant":1}},"sizeOvertimeModule":{"__type__":"cc.SizeOvertimeModule","size":{"__type__":"cc.CurveRange"},"x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"velocityOvertimeModule":{"__type__":"cc.VelocityOvertimeModule","_enable":true,"x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"},"speedModifier":{"__type__":"cc.CurveRange","constant":0.5}},"forceOvertimeModule":{"__type__":"cc.ForceOvertimeModule","x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"limitVelocityOvertimeModule":{"__type__":"cc.LimitVelocityOvertimeModule","limitX":{"__type__":"cc.CurveRange"},"limitY":{"__type__":"cc.CurveRange"},"limitZ":{"__type__":"cc.CurveRange"},"limit":{"__type__":"cc.CurveRange"}},"rotationOvertimeModule":{"__type__":"cc.RotationOvertimeModule","x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"textureAnimationModule":{"__type__":"cc.TextureAnimationModule","frameOverTime":{"__type__":"cc.CurveRange"},"startFrame":{"__type__":"cc.CurveRange"}},"trailModule":{"__type__":"cc.TrailModule","lifeTime":{"__type__":"cc.CurveRange","constant":1},"widthRatio":{"__type__":"cc.CurveRange"},"colorOverTrail":{"__type__":"cc.GradientRange"},"colorOvertime":{"__type__":"cc.GradientRange"},"_particleSystem":{"__id__":45}},"renderer":{"__type__":"cc.ParticleSystemRenderer"}},{"__type__":"cc.Node","_name":"Particle score","_parent":{"__id__":1},"_components":[{"__id__":45}],"_lpos":{"__type__":"cc.Vec3","x":-27.266},"_lrot":{"__type__":"cc.Quat","x":0.7071067811865475,"w":0.7071067811865476},"_euler":{"__type__":"cc.Vec3","x":90},"_id":"83I5MoD4lOFKiU24K0K5XK"},{"__type__":"cc.CurveRange","constant":0.6},{"__type__":"cc.CurveRange"},{"__type__":"cc.ParticleSystemComponent","_name":"Particle<ParticleSystemComponent>","node":{"__id__":50},"_materials":[{"__uuid__":"eadHiwQI1AUrcD8NI1Xglf"},null],"startColor":{"__type__":"cc.GradientRange"},"startSizeX":{"__id__":51},"startSize":{"__id__":51},"startSizeY":{"__type__":"cc.CurveRange"},"startSizeZ":{"__type__":"cc.CurveRange"},"startSpeed":{"__type__":"cc.CurveRange","constant":30},"startRotationX":{"__type__":"cc.CurveRange"},"startRotationY":{"__type__":"cc.CurveRange"},"startRotationZ":{"__id__":52},"startRotation":{"__id__":52},"startDelay":{"__type__":"cc.CurveRange"},"startLifetime":{"__type__":"cc.CurveRange","constant":0.1},"duration":0.3,"loop":false,"gravityModifier":{"__type__":"cc.CurveRange"},"rateOverTime":{"__type__":"cc.CurveRange","constant":80},"rateOverDistance":{"__type__":"cc.CurveRange"},"colorOverLifetimeModule":{"__type__":"cc.ColorOvertimeModule","color":{"__type__":"cc.GradientRange"}},"shapeModule":{"__type__":"cc.ShapeModule","_enable":true,"_shapeType":3,"shapeType":3,"arcSpeed":{"__type__":"cc.CurveRange","constant":1}},"sizeOvertimeModule":{"__type__":"cc.SizeOvertimeModule","size":{"__type__":"cc.CurveRange"},"x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"velocityOvertimeModule":{"__type__":"cc.VelocityOvertimeModule","_enable":true,"x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"},"speedModifier":{"__type__":"cc.CurveRange","constant":0.5}},"forceOvertimeModule":{"__type__":"cc.ForceOvertimeModule","x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"limitVelocityOvertimeModule":{"__type__":"cc.LimitVelocityOvertimeModule","limitX":{"__type__":"cc.CurveRange"},"limitY":{"__type__":"cc.CurveRange"},"limitZ":{"__type__":"cc.CurveRange"},"limit":{"__type__":"cc.CurveRange"}},"rotationOvertimeModule":{"__type__":"cc.RotationOvertimeModule","x":{"__type__":"cc.CurveRange"},"y":{"__type__":"cc.CurveRange"},"z":{"__type__":"cc.CurveRange"}},"textureAnimationModule":{"__type__":"cc.TextureAnimationModule","frameOverTime":{"__type__":"cc.CurveRange"},"startFrame":{"__type__":"cc.CurveRange"}},"trailModule":{"__type__":"cc.TrailModule","lifeTime":{"__type__":"cc.CurveRange","constant":1},"widthRatio":{"__type__":"cc.CurveRange"},"colorOverTrail":{"__type__":"cc.GradientRange"},"colorOvertime":{"__type__":"cc.GradientRange"},"_particleSystem":{"__id__":49}},"renderer":{"__type__":"cc.ParticleSystemRenderer"}},{"__type__":"cc.Node","_name":"Particle power","_parent":{"__id__":1},"_components":[{"__id__":49}],"_lpos":{"__type__":"cc.Vec3","x":-27.266},"_lrot":{"__type__":"cc.Quat","x":0.7071067811865475,"w":0.7071067811865476},"_euler":{"__type__":"cc.Vec3","x":90},"_id":"42CcR/rfZHsqM1Gh5oQXfv"},{"__type__":"cc.CurveRange","constant":0.6},{"__type__":"cc.CurveRange"},{"__type__":"cc.LabelComponent","node":{"__id__":54},"_string":"能量：","_actualFontSize":40},{"__type__":"cc.Node","_name":"power","_parent":{"__id__":55},"_active":false,"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":54},"_contentSize":{"__type__":"cc.Size","width":126,"height":50.4},"_anchorPoint":{"__type__":"cc.Vec2","y":0.5}},{"__id__":53},{"__type__":"cc.LabelOutlineComponent","node":{"__id__":54},"_color":{"__type__":"cc.Color"},"_width":3}],"_lpos":{"__type__":"cc.Vec3","x":18.123,"y":272},"_layer":33554432},{"__type__":"cc.Node","_name":"Canvas","_parent":{"__id__":1},"_children":[{"__id__":56},{"__id__":54}],"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":55},"_contentSize":{"__type__":"cc.Size","width":960,"height":640}},{"__type__":"cc.CanvasComponent","node":{"__id__":55}}],"_lpos":{"__type__":"cc.Vec3","x":480,"y":320,"z":1},"_layer":33554432,"_id":"caL+0CkxBA0p9X4EAP33TD"},{"__type__":"cc.Node","_name":"score","_parent":{"__id__":55},"_components":[{"__type__":"cc.UITransformComponent","node":{"__id__":56},"_contentSize":{"__type__":"cc.Size","width":126,"height":50.4},"_anchorPoint":{"__type__":"cc.Vec2","y":0.5}},{"__id__":57},{"__type__":"cc.LabelOutlineComponent","node":{"__id__":56},"_color":{"__type__":"cc.Color"},"_width":3}],"_lpos":{"__type__":"cc.Vec3","x":-401,"y":272},"_layer":33554432},{"__type__":"cc.LabelComponent","node":{"__id__":56},"_string":"分数：","_actualFontSize":40}],{"__type__":"cc.Material","_effectAsset":{"__uuid__":"a7YStUNeNCOKGpSntUY1g5"},"_defines":[{},{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{},{"mainColor":{"__type__":"cc.Color","r":236,"g":218,"b":180},"shadeColor1":{"__type__":"cc.Color","r":195,"g":161,"b":87},"shadeColor2":{"__type__":"cc.Color","r":122,"g":103,"b":63}}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"a7YStUNeNCOKGpSntUY1g5"},"_defines":[{},{}],"_states":[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],"_props":[{"baseColor":{"__type__":"cc.Color","r":255,"g":255,"b":255}},{"mainColor":{"__type__":"cc.Color","r":224,"g":36,"b":36},"shadeColor1":{"__type__":"cc.Color","r":158,"g":64,"b":51},"shadeColor2":{"__type__":"cc.Color","r":80,"g":14,"b":4},"baseStep":0.76}]},{"__type__":"cc.EffectAsset","_name":"builtin-particle","techniques":[{"name":"add","passes":[{"rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"value":[1,1,0,0],"type":16},"tintColor":{"value":[0.5,0.5,0.5,0.5],"type":16}}}]},{"name":"alpha-blend","passes":[{"rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"value":[1,1,0,0],"type":16},"tintColor":{"value":[0.5,0.5,0.5,0.5],"type":16}}}]},{"name":"add-multiply","passes":[{"rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"value":[1,1,0,0],"type":16},"tintColor":{"value":[0.5,0.5,0.5,0.5],"type":16}}}]},{"name":"add-smooth","passes":[{"rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"value":[1,1,0,0],"type":16}}}]},{"name":"premultiply-blend","passes":[{"rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"value":[1,1,0,0],"type":16}}}]}],"shaders":[{"hash":2171161221,"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"}],"blocks":[{"name":"Constants","members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[],"binding":0},{"name":"FragConstants","members":[{"name":"tintColor","type":16,"count":1}],"defines":[],"binding":1}],"samplers":[{"name":"mainTexture","type":28,"count":1,"defines":[],"binding":30}],"attributes":[{"name":"a_position","type":15,"count":1,"defines":[],"format":32,"location":0},{"name":"a_texCoord","type":15,"count":1,"defines":[],"format":32,"location":1},{"name":"a_texCoord1","type":15,"count":1,"defines":[],"format":32,"location":2},{"name":"a_texCoord2","type":15,"count":1,"defines":[],"format":32,"location":3},{"name":"a_color","type":16,"count":1,"defines":[],"format":43,"location":4},{"name":"a_color1","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":5},{"name":"a_texCoord3","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":6},{"name":"a_normal","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":7}],"record":null,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add"},{"hash":3680578336,"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"}],"blocks":[{"name":"Constants","members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[],"binding":0},{"name":"FragConstants","members":[{"name":"tintColor","type":16,"count":1}],"defines":[],"binding":1}],"samplers":[{"name":"mainTexture","type":28,"count":1,"defines":[],"binding":30}],"attributes":[{"name":"a_position","type":15,"count":1,"defines":[],"format":32,"location":0},{"name":"a_texCoord","type":15,"count":1,"defines":[],"format":32,"location":1},{"name":"a_texCoord1","type":15,"count":1,"defines":[],"format":32,"location":2},{"name":"a_texCoord2","type":15,"count":1,"defines":[],"format":32,"location":3},{"name":"a_color","type":16,"count":1,"defines":[],"format":43,"location":4},{"name":"a_color1","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":5},{"name":"a_texCoord3","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":6},{"name":"a_normal","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":7}],"record":null,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply"},{"hash":4020148043,"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"}],"blocks":[{"name":"Constants","members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[],"binding":0}],"samplers":[{"name":"mainTexture","type":28,"count":1,"defines":[],"binding":30}],"attributes":[{"name":"a_position","type":15,"count":1,"defines":[],"format":32,"location":0},{"name":"a_texCoord","type":15,"count":1,"defines":[],"format":32,"location":1},{"name":"a_texCoord1","type":15,"count":1,"defines":[],"format":32,"location":2},{"name":"a_texCoord2","type":15,"count":1,"defines":[],"format":32,"location":3},{"name":"a_color","type":16,"count":1,"defines":[],"format":43,"location":4},{"name":"a_color1","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":5},{"name":"a_texCoord3","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":6},{"name":"a_normal","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":7}],"record":null,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth"},{"hash":4156270969,"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"}],"blocks":[{"name":"Constants","members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[],"binding":0}],"samplers":[{"name":"mainTexture","type":28,"count":1,"defines":[],"binding":30}],"attributes":[{"name":"a_position","type":15,"count":1,"defines":[],"format":32,"location":0},{"name":"a_texCoord","type":15,"count":1,"defines":[],"format":32,"location":1},{"name":"a_texCoord1","type":15,"count":1,"defines":[],"format":32,"location":2},{"name":"a_texCoord2","type":15,"count":1,"defines":[],"format":32,"location":3},{"name":"a_color","type":16,"count":1,"defines":[],"format":43,"location":4},{"name":"a_color1","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":5},{"name":"a_texCoord3","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":6},{"name":"a_normal","type":15,"count":1,"defines":["CC_RENDER_MODE"],"format":32,"location":7}],"record":null,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied"}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"d1NGQ2rJZCcbhjH0/erZWw"},"_defines":[{}],"_props":[{"mainTexture":{"__uuid__":"b5snqx50BDmLQHhI/CssiX@6c48a"}}]}]
